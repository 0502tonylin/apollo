#!/usr/bin/env python3
import os
import sys

TAB = " " * 4

HEADER = """## Auto generated by `proto_build_generator.py`
load("@rules_proto//proto:defs.bzl", "proto_library")
load("@rules_cc//cc:defs.bzl", "cc_proto_library")
load("@com_github_grpc_grpc//bazel:python_rules.bzl", "py_proto_library")

package(default_visibility = ["//visibility:public"])

"""

TEMPLATE_NO_DEPS = """cc_proto_library(
    name = "{cc_name}",
    deps = [
        ":{pb_name}",
    ],
)

proto_library(
    name = "{pb_name}",
    srcs = ["{protofile}"],
)

py_proto_library(
    name = "{py_name}",
    deps = [
        ":{pb_name}",
    ],
)
"""

TEMPLATE_DEPS = """cc_proto_library(
    name = "{cc_name}",
    deps = [
        ":{pb_name}",
    ],
)

proto_library(
    name = "{pb_name}",
    srcs = ["{protofile}"],
    deps = [
        {context}
    ],
)

py_proto_library(
    name = "{py_name}",
    deps = [
        ":{pb_name}",
    ],
)

"""

TEMPLATE_DEPENDENCY_FIRST_ENTRY = """"{}","""
TEMPLATE_DEPENDENCY_OTHER_ENTRY = """
{}"{}","""

ALLOWED_MODULES = ["modules", "cyber"]


def _path_check(build_file_path):
    return any(
        build_file_path.startswith(mod + "/") for mod in ALLOWED_MODULES)


def autorun(build_file_path):
    if not _path_check(build_file_path):
        print("Expect to run this script at $APOLLO_ROOT_DIR")
        return

    workdir = os.path.dirname(build_file_path)
    files_all = [f for f in os.listdir(workdir) if \
                  os.path.isfile(os.path.join(workdir, f)) \
                  and f != "BUILD" \
                  and f != "CMakeLists.txt"]
    ok = all(f.endswith(".proto") for f in files_all)
    if not ok:
        print(
            "Except for BUILD/CMakeLists.txt, some files under {} are NOT proto files.".
            format(workdir))
        return

    fout = open(build_file_path, "w")
    fout.write(HEADER)

    for protofile in files_all:
        dependency_text = generate_dependency_text(workdir, protofile)
        rules = generate_rule_for_protofile(protofile, dependency_text)
        fout.write(rules)

    fout.close()
    print("Congratulations, {} was successfully generated.".format(
        build_file_path))


def generate_rule_for_protofile(protofile, dependency_text):
    cc_name = cc_proto_name(protofile)
    py_name = py_proto_name(protofile)
    pb_name = proto_name(protofile)
    if len(dependency_text) == 0:
        return TEMPLATE_NO_DEPS.format(cc_name=cc_name, \
                                        py_name=py_name, \
                                        pb_name=pb_name, \
                                        protofile=protofile)
    return TEMPLATE_DEPS.format(cc_name=cc_name, \
                                py_name=py_name, \
                                pb_name=pb_name, \
                                protofile=protofile, \
                                context=dependency_text)


def cc_proto_name(protofile):
    (sketch, _) = os.path.splitext(protofile)
    return sketch + "_cc_proto"


def py_proto_name(protofile):
    (sketch, _) = os.path.splitext(protofile)
    return sketch + "_py_pb2"


def proto_name(protofile):
    (sketch, _) = os.path.splitext(protofile)
    return sketch + "_proto"


def generate_dependency_text(workdir, protofile):
    dependencies = dependency_analysis(workdir, protofile)
    if len(dependencies) == 0:
        return ""
    notes = []
    for dep in dependencies:
        depdir = os.path.dirname(dep)
        depname = proto_name(os.path.basename(dep))
        if depdir == workdir:
            notes.append(":{}".format(depname))
        else:
            notes.append("//{}:{}".format(depdir, depname))
    result = TEMPLATE_DEPENDENCY_FIRST_ENTRY.format(notes[0])
    for note in notes[1:]:
        result += TEMPLATE_DEPENDENCY_OTHER_ENTRY.format(TAB * 2, note)
    return result


def _import_line_check(line):
    return "import " in line and \
            any("\"{}/".format(mod) in line for mod in ALLOWED_MODULES)


def dependency_analysis(workdir, protofile):
    dependencies = []
    fullpath = os.path.join(workdir, protofile)
    with open(fullpath) as fin:
        for line in fin:
            if _import_line_check(line):
                dependencies.append(line.split('"')[1])
    return dependencies


if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage:\n{}{} path/to/proto/BUILD".format(TAB, sys.argv[0]))
        sys.exit(1)

    autorun(sys.argv[1])
